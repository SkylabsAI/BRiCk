/*
 * Copyright (C) 2024 BlueRock Security, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1 WITH BedRock Exception for use over network, see repository root for details.
 */

/** ** Diagnostics with lazy strings */

typeabbrev lstring string -> prop.
namespace lstring {
  func default! string, lstring -> string.	% Verbose with <<Elpi Debug "DEBUG_DIAG".>>
}

kind diag type.
namespace diag {
  type ok diag.
  type error lstring -> diag.

  func interp diag ->.	% Panic on error
  func assert! (func diag ->), lstring ->.	% Panic with "Prefix: " on error
  :functional
  pred do! o:diag, i:list (diag -> prop).
  func lift-ok! prop, lstring -> diag.

  % Working with fixed strings

  func errors string -> diag.
  func asserts! (func diag ->) -> string.
  func lift-oks! (prop), string -> diag.

  % Working with <<diagnostic>>

  func of_diagnostic diagnostic -> diag.
  func to_diagnostic diag -> diagnostic.

  func lift! (func -> diagnostic) -> diag.
  func lower! (func -> diag) -> diagnostic.
}

/*
Implementation
*/

namespace lstring {
  default! _ F S :- F S, !.

  :if "DEBUG_DIAG"
  default! Default F S :- !,
    std.string.concat "" [
      Default, " (<<", {term_to_string F}, ">> failed)"
    ] S.

  default! S _ S.
}

namespace diag {

  macro @noloc :- "No location".
  macro @nomsg :- "No message".
  macro @nodiag :- "No diagnostic".

  func locate diag, lstring -> diag.
  locate diag.ok _ diag.ok :- !.
  locate (diag.error E) W (diag.error (locate.msg W E)) :- !.
  locate _ W (diag.error (locate.msg W ((=) @nodiag))).

  func locate.msg lstring, lstring -> string.
  locate.msg W E Msg :-
    std.string.concat "" [
      {lstring.default! @noloc W}, ": ",
      {lstring.default! @nomsg E},
    ] Msg.

  interp diag.ok :- !.
  interp (diag.error E) :- !, coq.error {lstring.default! @nomsg E}.
  interp _ :- coq.error @nodiag.

  assert! P W :- P D, !, interp {locate D W}.
  assert! _ W :- coq.error {lstring.default! @noloc W} ":" @nodiag.

  do! diag.ok [].
  do! D [P|Ps] :- P Diag, !, if (Diag = diag.ok) (do! D Ps) (D = Diag).

  lift-ok! P _ diag.ok :- P, !.
  lift-ok! _ E (diag.error E).

  errors S (diag.error ((=) S)).
  asserts! Ps S :- diag.assert! Ps ((=) S).
  lift-oks! P S D :- lift-ok! P ((=) S) D.

  of_diagnostic ok diag.ok :- !.
  of_diagnostic (error S) (diag.error ((=) S)) :- !.
  of_diagnostic _ (diag.error ((=) @nodiag)).

  to_diagnostic diag.ok ok :- !.
  to_diagnostic (diag.error E) (error S) :- !, lstring.default! @nomsg E S.
  to_diagnostic _ (error @nodiag).

  lift! P D :- P Diag, !, of_diagnostic Diag D.
  lift! _ (diag.error ((=) @nodiag)).

  lower! P D :- P Diag, !, to_diagnostic Diag D.
  lower! _ (error @nodiag).
}
