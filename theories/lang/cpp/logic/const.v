(*
 * Copyright (c) 2020 BedRock Systems, Inc.
 *
 * This software is distributed under the terms of the BedRock Open-Source License.
 * See the LICENSE-BedRock file in the repository root for details.
 *)
From bedrock.lang.bi Require Export monpred.
From iris.proofmode Require Import proofmode monpred.
Require Import iris.bi.lib.fractional.


Require Import bedrock.prelude.base.

From bedrock.lang.cpp Require Import
  semantics ast logic.pred logic.path_pred logic.rep logic.rep_defs heap_notations
  heap_pred layout.


Section defs.
  Context `{Σ : cpp_logic}  {σ : genv} {tu : translation_unit}.

  (* TODO: change to const core? *)
  Parameter downcast_to_const_base : mpred.
  Fixpoint cast_aux (fuel : nat) (q_c q_c' : bool)  (addr : ptr) (ty : type) (q : cQp) (Q : mpred) : mpred :=
    match fuel with
    | 0 => downcast_to_const_base
    | S n => let cq : cQp := (cqp.mk q_c (frac q)) in
            let cq' : cQp := (cqp.mk q_c' (frac q)) in
            match ty with
            | Tptr _
            | Tref _
            | Trv_ref _
            | Tnum _ _
            | Tbool
            | Tnullptr
            | Tvoid => (Exists v, addr |-> primR Tint cq v **
                           (addr |-> primR Tint cq' v -* Q)) ∨
                (addr |-> uninitR Tint cq **
                   (addr |-> uninitR Tint cq' -* Q))
            | Tarray _ _ => False (* TODO *)
            | Tnamed cls => match (*glob_def σ cls *) tu.(globals) !! cls with
                           | None => False (* correct *)
                           | Some gd =>
                               match gd with
                               | Gtype => False  (* correct *)
                               | Gunion _ => False
                               | Gstruct st =>
                                   fold_left (fun Q '(b, _) =>
                                                cast_aux n q_c q_c' (addr ,, _base cls b) (Tnamed b) q Q
                                     ) (s_bases st) $
                                     fold_left (fun Q f =>
                                                  if f.(mem_mutable) then Q
                                                  else cast_aux n q_c q_c'
                                                         (addr ,, _field {| f_type := cls; f_name := f.(mem_name) |})
                                                         f.(mem_type) q Q
                                     )
                                     (s_fields st)
                                     (addr |-> struct_paddingR cq cls ** (addr |-> struct_paddingR cq' cls -* Q))
                               | Genum _ _ => False (* TODO - check *)
                               | Gconstant _ _ => False (* correct *)
                               | Gtypedef _ => False (* correct - not generated by cpp2v *)
                               end
                           end
            | Tqualified t_c ty' =>
                match t_c with
                | QCV | QC => Q
                | _ => cast_aux n q_c q_c' addr ty' q Q
                end
            | Tenum _ => False (* TODO *)

            | Tmember_pointer _ _
            | Tfloat _
            | Tfunction _ _
            | Tarch _ _ => False
            end
    end.

  Definition wp_downcast_to_const := cast_aux 5 false true.
  Definition wp_upcast_to_mutable := cast_aux 5 true false.

  Lemma cast_aux_frame : forall tu n b b' p ty q (Q Q' : epred),
    Q -* Q' |-- cast_aux (tu := tu) n b b' p ty q Q -* cast_aux (tu := tu) n b b' p ty q Q'.
  Proof.
    move=>? n; induction n; first by iIntros.

    move=>b b' p.
    case; try by [simpl; auto | intros; iIntros "W [[% [?K]]|[?K]]"; [iLeft; iExists _ | iRight];
      iFrame; iIntros "?"; iApply "W"; iApply "K"].

    - iIntros (cls q Q Q') "W //=".

      case: (_ !! _)=>[a|]; last done.
      case: a; try done.


      admit.
  Admitted.


End defs.
