(*
 * Copyright (c) 2020 BedRock Systems, Inc.
 *
 * This software is distributed under the terms of the BedRock Open-Source License.
 * See the LICENSE-BedRock file in the repository root for details.
 *)
From bedrock.lang.bi Require Export monpred.
From iris.proofmode Require Import proofmode monpred.
Require Import iris.bi.lib.fractional.


Require Import bedrock.prelude.base.

From bedrock.lang.cpp Require Import
  semantics ast logic.pred logic.path_pred logic.rep logic.rep_defs heap_notations
  heap_pred layout logic.wp.


Section defs.
  Context `{Σ : cpp_logic}  {σ : genv} {tu : translation_unit}.

  (* [cv_cast from to addr ty Q] replaces the [from] ownership of [ty] at [addr] with
     [to] ownership and then proceeds as [Q].

     This is used to implement [wp_downcast_to_const] and [wp_upcast_to_const].
   *)
  Parameter cv_cast : forall (from to : CV.t) (addr : ptr) (ty : type) (Q : mpred), mpred.
  Axiom cv_cast_frame : forall f t a ty Q Q',
      Q -* Q' |-- cv_cast f t a ty Q -* cv_cast f t a ty Q'.

  Definition wp_downcast_to_const := cv_cast (CV.m 1) (CV.c 1).
  Definition wp_upcast_to_mutable := cv_cast (CV.c 1) (CV.m 1).

  Definition cv_cast_body (cv_cast : forall (from to : CV.t) (addr : ptr) (ty : type) (Q : mpred), mpred)
    (from to : CV.t)  (addr : ptr) (ty : type) (Q : mpred) : mpred :=
    let UNSUPPORTED := cv_cast from to addr ty Q in
    let '(cv, rty) := decompose_type ty in
    if q_const cv then Q
    else
      match rty with
      | Tptr _
      | Tref _
      | Trv_ref _
      | Tnum _ _
      | Tbool
      | Tnullptr
      | Tenum _
      | Tmember_pointer _ _
      | Tfloat _
      | Tvoid =>
          (Exists v, addr |-> primR rty from v ** (addr |-> primR rty to v -* Q)) ∨
          (          addr |-> uninitR rty from ** (addr |-> uninitR rty to -* Q))
      | Tarray ety sz =>
          fold_left (fun Q i =>
            cv_cast from to (addr .[ erase_qualifiers ety ! sz ]) ty Q)
                    (seqN 0 sz) Q
      | Tnamed cls =>
          match tu.(globals) !! cls with
          | None => False (* correct *)
          | Some gd =>
              match gd with
              | Gtype => False  (* correct *)
              | Gunion u =>
                Exists br, addr |-> union_paddingR from cls br ** (addr |-> union_paddingR to cls br -*
                match br with
                | None =>  Q
                | Some br => match u.(u_fields) !! br with
                            | None => False
                            | Some m =>
                                if m.(mem_mutable) then Q
                                else
                                  cv_cast from to (addr ,, _field {| f_type := cls ; f_name := m.(mem_name) |}) m.(mem_type) Q
                            end
                end)
              | Gstruct st =>
                  fold_left (fun Q '(b, _) =>
                              cv_cast from to (addr ,, _base cls b) (Tnamed b) Q)
                    (s_bases st) $
                    fold_left (fun Q f =>
                                if f.(mem_mutable) then Q
                                else cv_cast from to
                                        (addr ,, _field {| f_type := cls; f_name := f.(mem_name) |})
                                        f.(mem_type) Q)
                    (s_fields st)
                    (addr |-> struct_paddingR from cls ** (addr |-> struct_paddingR to cls -* Q))
              | Genum _ _ => UNSUPPORTED (* correct *)
              | Gconstant _ _ => UNSUPPORTED (* correct *)
              | Gtypedef _ => UNSUPPORTED (* correct - not generated by cpp2v *)
              end
          end
      | Tfunction _ _
      | Tarch _ _ => UNSUPPORTED
      | Tqualified cv ty' => False (* unreachable *)
      end%I.

  Axiom cv_cast_unfold : forall f t a ty Q, cv_cast_body cv_cast f t a ty Q = cv_cast f t a ty Q.

  (* Should include a sanity check for the frame condition *)

  (*
  Fixpoint cast_aux (fuel : nat) (from to : CV.t)  (addr : ptr) (ty : type) (Q : mpred) {struct fuel} : mpred :=
    match fuel with
    | 0 => cv_cast from to addr ty Q
    | S n =>
      let '(cv, ty) := decompose_type ty in
      if q_const cv then Q
      else
        match ty with
        | Tptr _
        | Tref _
        | Trv_ref _
        | Tnum _ _
        | Tbool
        | Tnullptr
        | Tenum _
        | Tmember_pointer _ _
        | Tfloat _
        | Tvoid =>
            (Exists v, addr |-> primR ty from v ** (addr |-> primR ty to v -* Q)) ∨
            (          addr |-> uninitR ty from ** (addr |-> uninitR ty to -* Q))
        | Tarray _ _ => False (* TODO *)
        | Tnamed cls =>
            match tu.(globals) !! cls with
            | None => False (* correct *)
            | Some gd =>
                match gd with
                | Gtype => False  (* correct *)
                | Gunion u =>
                  Exists br, addr |-> union_paddingR from cls br ** (addr |-> union_paddingR to cls br -*
                  match br with
                  | None =>  Q
                  | Some br => match u.(u_fields) !! br with
                             | None => False
                             | Some m =>
                                 if m.(mem_mutable) then Q
                                 else
                                   cast_aux n from to (addr ,, _field {| f_type := cls ; f_name := m.(mem_name) |}) m.(mem_type) Q
                             end
                  end)
                | Gstruct st =>
                    fold_left (fun Q '(b, _) =>
                                cast_aux n from to (addr ,, _base cls b) (Tnamed b) Q)
                      (s_bases st) $
                      fold_left (fun Q f =>
                                  if f.(mem_mutable) then Q
                                  else cast_aux n from to
                                          (addr ,, _field {| f_type := cls; f_name := f.(mem_name) |})
                                          f.(mem_type) Q)
                      (s_fields st)
                      (addr |-> struct_paddingR from cls ** (addr |-> struct_paddingR to cls -* Q))
                | Genum _ _ => False (* correct *)
                | Gconstant _ _ => False (* correct *)
                | Gtypedef _ => False (* correct - not generated by cpp2v *)
                end
            end
        | Tqualified cv ty' => False (* unreachable *)
        | Tfunction _ _
        | Tarch _ _ => False
        end%I
    end.

  (* [cast_aux] is the unfolding of [cv_cast] *)
  Axiom cv_cast_unfold : forall fuel from to addr ty Q, cv_cast from to addr ty Q -|- cast_aux fuel from to addr ty Q.

  Lemma fold_frame : forall B (l : list B) (f : epred -> B -> epred)  (Q Q' : epred),
    (Q -* Q') |-- □ (Forall Q1 Q1' a, (Q1 -* Q1') -* (f Q1 a -* f Q1' a)) -*  fold_left f l Q -* fold_left f l Q'.
  Proof.
    move=>B l.
    induction l; iIntros (???) "W #F"; first done.
    iDestruct ("F" $! Q Q' a with "W") as "W".
    iApply (IHl with "W"). eauto.
  Qed.

  (* Sanity check *)
  Lemma cast_aux_frame : forall n q q' p ty (Q Q' : epred),
    Q -* Q' |-- cast_aux n q q' p ty Q -* cast_aux n q q' p ty Q'.
  Proof.
    induction n; simpl; intros; first by apply cv_cast_frame.

    case_match; case_match; eauto.
    case_match; try by [simpl; auto | intros; iIntros "W [[% [?K]]|[?K]]"; [iLeft; iExists _ | iRight];
      iFrame; iIntros "?"; iApply "W"; iApply "K"].

    case_match; eauto.
    case_match; eauto.
    { (* unions *)
      iIntros "F X"; iDestruct "X" as (?) "X".
      iExists _; iDestruct "X" as "[$ X]".
      iIntros "Y"; iSpecialize ("X" with "Y").
      case_match; last by iApply "F".
      case_match; eauto.
      case_match; first by iApply "F".
      iRevert "X"; iApply IHn; eauto. }
    { (* struct *)
      iIntros "F".
      iApply (fold_frame with "[F]").
      { iApply (fold_frame with "[F]").
        { iIntros "[$ X] Y"; iApply "F"; iApply "X"; eauto. }
        { iModIntro.
          iIntros (???) "F". case_match; eauto.
          iApply IHn; eauto. } }
      { iModIntro.
        iIntros (???) "F". case_match; eauto.
        iApply IHn; eauto. } }
  Qed.
  *)

End defs.
